---
title: 常用公式
date: 2016-06-01 10:31:18
tags: as 公式
---
```sh
/*
 *  根据两点计算线段的角度 
 * @param pointa
 * @param pointb
 */

    private function getAngleByPoint(pointa:Point,pointb:Point):Number
    {
        var angle:Number;
        angle=(Math.atan2(pointb.y-pointa.y,pointb.x-pointa.x)*180/Math.PI);  //转换为角度，
        return angle;
    }
 /**
 *  角度转化弧度 
 * @param angle
 * @return 
 * 
 */
    private function angleToRadian(angle:Number):Number{
        return angle*(Math.PI/180);
    }
/**
 * 弧度转化角度 
 * @param radian
 * @return 
 * 
 */
    private function radianToAngle(radian:Number):Number{
        return radian*(180/Math.PI);
    }
/**
 *  方向位移的Y值 
 * @param angle
 * @return 
 * 
 */
    private function sinD(angle:Number):Number{
        return Math.sin(angleToRadian(angle));
    }
/**
 * 方向位移的X值 
 * @param angle
 * @return 
 * 
 */
    private function cosD(angle:Number):Number{
        return Math.cos(angleToRadian(angle));
    }
/**
* 求两条线段的交点 
* @param
* @return 
* 
*/
    private function getIntersection(a:Point,b:Point,c:Point,d:Point):Point { 
        var intersection:Point = new Point(Math.PI, Math.PI); 
    
    if (Math.abs(b.y - a.y) + Math.abs(b.x - a.x) + Math.abs(d.y - c.y) + Math.abs(d.x - c.x) == 0) { 
    if ((c.x - a.x) + (c.y - a.y) == 0) { 
            trace("ABCD是同一个点！"); 
        } else { 
            trace("AB是一个点，CD是一个点，且AC不同！"); 
        } 
            return intersection; 
        } 
    
    if (Math.abs(b.y - a.y) + Math.abs(b.x - a.x) == 0) { 
    if ((a.x - d.x) * (c.y - d.y) - (a.y - d.y) * (c.x - d.x) == 0) { 
             trace("A、B是一个点，且在CD线段上！"); 
        } else { 
            trace("A、B是一个点，且不在CD线段上！"); 
        } 
    return intersection; 
    } 
    if (Math.abs(d.y - c.y) + Math.abs(d.x - c.x) == 0) { 
        if ((d.x - b.x) * (a.y - b.y) - (d.y - b.y) * (a.x - b.x) == 0) { 
            trace("C、D是一个点，且在AB线段上！"); 
        } else { 
            trace("C、D是一个点，且不在AB线段上！"); 
        } 
    return intersection; 
    } 
    
    if ((b.y - a.y) * (c.x - d.x) - (b.x - a.x) * (c.y - d.y) == 0) { 
         trace("线段平行，无交点！"); 
         return intersection; 
    } 

    intersection.x = ((b.x - a.x) * (c.x - d.x) * (c.y - a.y) -  
    c.x * (b.x - a.x) * (c.y - d.y) + a.x * (b.y - a.y) * (c.x - d.x)) /  
    ((b.y - a.y) * (c.x - d.x) - (b.x - a.x) * (c.y - d.y)); 
    intersection.y = ((b.y - a.y) * (c.y - d.y) * (c.x - a.x) - c.y 
    * (b.y - a.y) * (c.x - d.x) + a.y * (b.x - a.x) * (c.y - d.y)) 
    / ((b.x - a.x) * (c.y - d.y) - (b.y - a.y) * (c.x - d.x)); 
    
    if ((intersection.x - a.x) * (intersection.x - b.x) <= 0 
    && (intersection.x - c.x) * (intersection.x - d.x) <= 0 
    && (intersection.y - a.y) * (intersection.y - b.y) <= 0 
    && (intersection.y - c.y) * (intersection.y - d.y) <= 0) { 
    
    //trace("线段相交于点(" + intersection.x + "," + intersection.y + ")！");  
        return intersection; // '相交  
    } else { 
    //trace("线段相交于虚交点(" + intersection.x + "," + intersection.y + ")！");  
        return new Point(Math.PI,Math.PI); // '相交但不在线段上  
    } 
    }  
```